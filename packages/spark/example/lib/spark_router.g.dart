// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by spark_generator
// ignore_for_file: type=lint

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:isolate';
import 'dart:math';

import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart' as shelf_io;
import 'package:shelf_router/shelf_router.dart';
import 'package:spark_framework/server.dart';

import 'package:spark_example/endpoints/endpoints.dart';
import 'package:spark_example/pages/home_page.dart';
import 'package:spark_example/pages/no_component/no_component_page.dart';
import 'package:spark_example/pages/test/test_page.dart';

// Helper functions for page rendering

Response _$renderPageResponse<T>(
  SparkPage<T> page,
  T data,
  PageRequest request,
  int statusCode,
  Map<String, Object> headers,
  List<Cookie> cookies,
  String? scriptName,
  String? nonce,
) {
  final content = runZoned(
    () => page.render(data, request).toString(),
    zoneValues: {'spark.cspNonce': nonce},
  );

  final title = page.title(data, request);

  final html = renderPage(
    title: title,
    content: content,
    scriptName: scriptName,
    stylesheets: page.stylesheets,
    additionalScripts: page.additionalScripts,
    inlineStyles: page.inlineStyles,
    headContent: page.headContent,
    lang: page.lang,
    nonce: nonce,
  );

  return Response(
    statusCode,
    body: html,
    headers: {
      'content-type': 'text/html; charset=utf-8',
      ...headers,
      if (cookies.isNotEmpty)
        HttpHeaders.setCookieHeader: cookies.map((c) => c.toString()).toList(),
    },
  );
}

Response _$renderErrorResponse(
  String message,
  int statusCode,
  List<Cookie> cookies,
) {
  final html = renderPage(
    title: 'Error $statusCode',
    content:
        '''
      <main style="text-align: center; padding: 40px;">
        <h1>Error $statusCode</h1>
        <p>$message</p>
      </main>
    ''',
  );

  return Response(
    statusCode,
    body: html,
    headers: {
      'content-type': 'text/html; charset=utf-8',
      if (cookies.isNotEmpty)
        HttpHeaders.setCookieHeader: cookies.map((c) => c.toString()).toList(),
    },
  );
}

Future<Response> _$handleHelloEndpoint(Request request) async {
  final endpoint = HelloEndpoint();

  var pipeline = const Pipeline();
  for (final middleware in endpoint.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    try {
      final sparkRequest = SparkRequest(shelfRequest: req, pathParams: {});

      final result = await endpoint.handler(sparkRequest);

      return Response.ok(result, headers: {"content-type": "text/plain"});
    } on SparkValidationException catch (e) {
      return ApiError(
        message: e.message,
        code: 'VALIDATION_ERROR',
        details: e.errors,
      ).toResponse(400);
    } on ApiError catch (e) {
      return e.toResponse();
    } on SparkHttpException catch (e) {
      return ApiError(
        message: e.message,
        code: e.code,
        details: e.details,
      ).toResponse(e.statusCode);
    } catch (e, s) {
      print(e);
      return ApiError(
        message: 'Internal Server Error',
        code: 'INTERNAL_ERROR',
      ).toResponse(500);
    }
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleEchoUserEndpoint(Request request) async {
  final endpoint = EchoUserEndpoint();

  var pipeline = const Pipeline();
  for (final middleware in endpoint.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    try {
      final sparkRequest = SparkRequest(shelfRequest: req, pathParams: {});

      final validatingContentType = req.headers['content-type'];
      if (validatingContentType != null) {
        const allowedTypes = ['application/json'];
        final mimeType = validatingContentType.split(';').first.trim();
        if (!allowedTypes.contains(mimeType)) {
          throw SparkHttpException(
            400,
            'Invalid Content-Type',
            code: 'INVALID_CONTENT_TYPE',
            details: {'allowed': allowedTypes},
          );
        }
      }

      dynamic rawBody;
      final contentTypeHeader = req.headers["content-type"];
      final contentType = ContentType.from(contentTypeHeader);
      if (contentType == ContentType.json) {
        final bodyString = await req.readAsString();
        rawBody = jsonDecode(bodyString);
      }
      final body = UserDto(
        name: (rawBody as Map<String, dynamic>)["name"].toString(),
      );
      final validationErrors = <String, dynamic>{};
      if (body.name.length < 10) {
        validationErrors['name'] = {
          'code': 'VALIDATION_MIN_LENGTH',
          'message': "Field 'name' must be at least 10 characters long",
          'min': 10,
        };
      }

      if (validationErrors.isNotEmpty) {
        throw SparkValidationException(validationErrors);
      }
      final result = await endpoint.handler(sparkRequest, body);

      return Response.ok(
        jsonEncode({'name': result.name}),
        headers: {"content-type": "application/json"},
      );
    } on SparkValidationException catch (e) {
      return ApiError(
        message: e.message,
        code: 'VALIDATION_ERROR',
        details: e.errors,
      ).toResponse(400);
    } on ApiError catch (e) {
      return e.toResponse();
    } on SparkHttpException catch (e) {
      return ApiError(
        message: e.message,
        code: e.code,
        details: e.details,
      ).toResponse(e.statusCode);
    } catch (e, s) {
      print(e);
      return ApiError(
        message: 'Internal Server Error',
        code: 'INTERNAL_ERROR',
      ).toResponse(500);
    }
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleEchoDetailsEndpoint(Request request) async {
  final endpoint = EchoDetailsEndpoint();

  var pipeline = const Pipeline();
  for (final middleware in endpoint.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    try {
      final sparkRequest = SparkRequest(shelfRequest: req, pathParams: {});

      dynamic rawBody;
      final contentTypeHeader = req.headers["content-type"];
      final contentType = ContentType.from(contentTypeHeader);
      if (contentType == ContentType.multipart) {
        final formData = <String, dynamic>{};
        await for (final part in sparkRequest.multipart) {
          if (part.filename == null) {
            final value = await part.readString();
            formData[part.name ?? ""] = value;
          }
        }
        rawBody = formData;
      } else if (contentType == ContentType.formUrlEncoded) {
        final bodyString = await req.readAsString();
        rawBody = Uri.splitQueryString(bodyString);
      } else if (contentType == ContentType.json) {
        final bodyString = await req.readAsString();
        rawBody = jsonDecode(bodyString);
      } else {
        rawBody = await req.readAsString();
      }
      final body = rawBody as Map<String, dynamic>;
      final result = await endpoint.handler(sparkRequest, body);

      return Response.ok(
        jsonEncode(result.map((k, v) => MapEntry(k, v))),
        headers: {"content-type": "application/json"},
      );
    } on SparkValidationException catch (e) {
      return ApiError(
        message: e.message,
        code: 'VALIDATION_ERROR',
        details: e.errors,
      ).toResponse(400);
    } on ApiError catch (e) {
      return e.toResponse();
    } on SparkHttpException catch (e) {
      return ApiError(
        message: e.message,
        code: e.code,
        details: e.details,
      ).toResponse(e.statusCode);
    } catch (e, s) {
      print(e);
      return ApiError(
        message: 'Internal Server Error',
        code: 'INTERNAL_ERROR',
      ).toResponse(500);
    }
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleCheckMwEndpoint(Request request) async {
  final endpoint = CheckMwEndpoint();

  var pipeline = const Pipeline();
  for (final middleware in endpoint.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    try {
      final sparkRequest = SparkRequest(shelfRequest: req, pathParams: {});

      final result = await endpoint.handler(sparkRequest);

      return Response.ok(result, headers: {"content-type": "text/plain"});
    } on SparkValidationException catch (e) {
      return ApiError(
        message: e.message,
        code: 'VALIDATION_ERROR',
        details: e.errors,
      ).toResponse(400);
    } on ApiError catch (e) {
      return e.toResponse();
    } on SparkHttpException catch (e) {
      return ApiError(
        message: e.message,
        code: e.code,
        details: e.details,
      ).toResponse(e.statusCode);
    } catch (e, s) {
      print(e);
      return ApiError(
        message: 'Internal Server Error',
        code: 'INTERNAL_ERROR',
      ).toResponse(500);
    }
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleGetUserEndpoint(Request request, String id) async {
  final endpoint = GetUserEndpoint();

  var pipeline = const Pipeline();
  for (final middleware in endpoint.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    try {
      final sparkRequest = SparkRequest(
        shelfRequest: req,
        pathParams: {'id': id},
      );

      final result = await endpoint.handler(sparkRequest);

      return Response.ok(
        jsonEncode({'name': result.name}),
        headers: {"content-type": "application/json"},
      );
    } on SparkValidationException catch (e) {
      return ApiError(
        message: e.message,
        code: 'VALIDATION_ERROR',
        details: e.errors,
      ).toResponse(400);
    } on ApiError catch (e) {
      return e.toResponse();
    } on SparkHttpException catch (e) {
      return ApiError(
        message: e.message,
        code: e.code,
        details: e.details,
      ).toResponse(e.statusCode);
    } catch (e, s) {
      print(e);
      return ApiError(
        message: 'Internal Server Error',
        code: 'INTERNAL_ERROR',
      ).toResponse(500);
    }
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleHomePage(Request request) async {
  final page = HomePage();
  var pipeline = const Pipeline();
  for (final middleware in page.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    final pageRequest = PageRequest(shelfRequest: req, pathParams: {});

    final response = await page.loader(pageRequest);

    return switch (response) {
      PageData(
        :final data,
        :final statusCode,
        :final headers,
        :final cookies,
      ) =>
        _$renderPageResponse(
          page,
          data,
          pageRequest,
          statusCode,
          headers,
          cookies,
          'home_page.dart.js',
          req.context['spark.nonce'] as String?,
        ),
      PageRedirect(
        :final location,
        :final statusCode,
        :final headers,
        :final cookies,
      ) =>
        Response(
          statusCode,
          headers: {
            ...headers,
            'location': location,
            if (cookies.isNotEmpty)
              HttpHeaders.setCookieHeader: cookies
                  .map((c) => c.toString())
                  .toList(),
          },
        ),
      PageError(:final message, :final statusCode, :final cookies) =>
        _$renderErrorResponse(message, statusCode, cookies),
    };
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleNoComponentPage(Request request) async {
  final page = NoComponentPage();
  var pipeline = const Pipeline();
  for (final middleware in page.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    final pageRequest = PageRequest(shelfRequest: req, pathParams: {});

    final response = await page.loader(pageRequest);

    return switch (response) {
      PageData(
        :final data,
        :final statusCode,
        :final headers,
        :final cookies,
      ) =>
        _$renderPageResponse(
          page,
          data,
          pageRequest,
          statusCode,
          headers,
          cookies,
          null,
          req.context['spark.nonce'] as String?,
        ),
      PageRedirect(
        :final location,
        :final statusCode,
        :final headers,
        :final cookies,
      ) =>
        Response(
          statusCode,
          headers: {
            ...headers,
            'location': location,
            if (cookies.isNotEmpty)
              HttpHeaders.setCookieHeader: cookies
                  .map((c) => c.toString())
                  .toList(),
          },
        ),
      PageError(:final message, :final statusCode, :final cookies) =>
        _$renderErrorResponse(message, statusCode, cookies),
    };
  };

  return pipeline.addHandler(handler)(request);
}

Future<Response> _$handleTestPage(Request request) async {
  final page = TestPage();
  var pipeline = const Pipeline();
  for (final middleware in page.middleware) {
    pipeline = pipeline.addMiddleware(middleware);
  }

  final handler = (Request req) async {
    final pageRequest = PageRequest(shelfRequest: req, pathParams: {});

    final response = await page.loader(pageRequest);

    return switch (response) {
      PageData(
        :final data,
        :final statusCode,
        :final headers,
        :final cookies,
      ) =>
        _$renderPageResponse(
          page,
          data,
          pageRequest,
          statusCode,
          headers,
          cookies,
          'test/test_page.dart.js',
          req.context['spark.nonce'] as String?,
        ),
      PageRedirect(
        :final location,
        :final statusCode,
        :final headers,
        :final cookies,
      ) =>
        Response(
          statusCode,
          headers: {
            ...headers,
            'location': location,
            if (cookies.isNotEmpty)
              HttpHeaders.setCookieHeader: cookies
                  .map((c) => c.toString())
                  .toList(),
          },
        ),
      PageError(:final message, :final statusCode, :final cookies) =>
        _$renderErrorResponse(message, statusCode, cookies),
    };
  };

  return pipeline.addHandler(handler)(request);
}

/// Creates a router with all registered Spark pages.
///
/// This router contains handlers for:
/// - `/api/hello` -> HelloEndpoint
/// - `/api/echo` -> EchoUserEndpoint
/// - `/api/details` -> EchoDetailsEndpoint
/// - `/api/check` -> CheckMwEndpoint
/// - `/api/users/<id>` -> GetUserEndpoint
/// - `/` -> HomePage
/// - `/no-component` -> NoComponentPage
/// - `/test` -> TestPage
Router createSparkRouter() {
  final router = Router();

  router.get('/api/hello', _$handleHelloEndpoint);
  router.post('/api/echo', _$handleEchoUserEndpoint);
  router.post('/api/details', _$handleEchoDetailsEndpoint);
  router.get('/api/check', _$handleCheckMwEndpoint);
  router.get(
    '/api/users/<id>',
    (Request request, String id) => _$handleGetUserEndpoint(request, id),
  );
  router.get('/', _$handleHomePage);
  router.get('/no-component', _$handleNoComponentPage);
  router.get('/test', _$handleTestPage);

  return router;
}

/// Configuration for the Spark server.
class SparkServerConfig {
  /// The host to bind to. Defaults to `localhost`.
  /// Can be a [String] or [InternetAddress].
  final Object host;

  /// The port to listen on. Defaults to `8080`.
  final int port;

  /// Middleware to apply to all requests.
  final List<Middleware> middleware;

  /// Configuration for static file serving.
  final StaticHandlerConfig? staticConfig;

  /// Handler for 404 errors.
  final Handler? notFoundHandler;

  /// Security context for HTTPS.
  final SecurityContext? securityContext;

  /// Whether to share the server socket.
  final bool shared;

  /// Whether to redirect HTTP to HTTPS.
  final bool redirectToHttps;

  /// Number of isolates (threads) to spawn.
  final int? isolates;

  /// Creates a server configuration.
  const SparkServerConfig({
    this.host = 'localhost',
    this.port = 8080,
    this.middleware = const [],
    this.staticConfig,
    this.notFoundHandler,
    this.securityContext,
    this.shared = false,
    this.redirectToHttps = false,
    this.isolates,
  });
}

/// Creates and starts a Spark server with all registered pages.
///
/// ## Usage
///
/// ```dart
/// void main() async {
///   final server = await createSparkServer(SparkServerConfig(
///     port: 8080,
///     middleware: [logRequests()],
///   ));
///   print('Server running at http://${server.address.host}:${server.port}');
/// }
/// ```
Future<HttpServer> createSparkServer([SparkServerConfig? config]) async {
  config ??= const SparkServerConfig();

  // Auto-detect static path based on runtime environment
  final isDevMode = Platform.environment.containsKey('SPARK_DEV_RELOAD_PORT');
  final staticPath = isDevMode ? 'build/web' : 'web';

  // Automatic threading
  if (config.isolates != null && config.isolates! > 1) {
    if (Platform.environment['SPARK_WORKER_ID'] == null) {
      print('[Master] Spawning ${config.isolates! - 1} workers...');
      // Allow the master to also serve
      for (var i = 1; i < config.isolates!; i++) {
        Isolate.spawnUri(
          Platform.script,
          [],
          null,
          packageConfig: await Isolate.packageConfig,
          environment: {'SPARK_WORKER_ID': '$i', ...Platform.environment},
        );
      }
    } else {
      print(
        '[Worker] Started worker ${Platform.environment['SPARK_WORKER_ID']}',
      );
    }
  }

  var pipeline = const Pipeline();

  // Add global error handler
  pipeline = pipeline.addMiddleware((innerHandler) {
    return (request) async {
      try {
        return await innerHandler(request);
      } on ApiError catch (e) {
        return e.toResponse();
      } catch (e, s) {
        print(e);
        print(s);
        return Response.internalServerError();
      }
    };
  });

  // CSP Middleware
  pipeline = pipeline.addMiddleware((innerHandler) {
    return (request) async {
      // 1. Generate nonce
      final nonceBytes = List<int>.generate(
        16,
        (_) => Random.secure().nextInt(256),
      );
      final nonce = base64Url.encode(nonceBytes).replaceAll('=', '');

      // 2. Add to context
      final requestWithNonce = request.change(
        context: {...request.context, 'spark.nonce': nonce},
      );

      // 3. Process request
      final response = await innerHandler(requestWithNonce);

      // 4. Check for existing CSP header
      final csp = response.headers['content-security-policy'];
      if (csp == null) {
        return response;
      }

      // 5. Augment existing CSP
      var newCsp = csp;

      // Handle script-src
      if (newCsp.contains(RegExp(r'\bscript-src\b'))) {
        newCsp = newCsp.replaceAll(
          RegExp(r'\bscript-src\b'),
          "script-src 'nonce-$nonce'",
        );
      } else {
        newCsp = "$newCsp; script-src 'self' 'nonce-$nonce'";
      }

      // Handle style-src
      if (newCsp.contains(RegExp(r'\bstyle-src\b'))) {
        newCsp = newCsp.replaceAll(
          RegExp(r'\bstyle-src\b'),
          "style-src 'nonce-$nonce'",
        );
      } else {
        newCsp = "$newCsp; style-src 'self' 'nonce-$nonce'";
      }

      return response.change(
        headers: {...response.headers, 'content-security-policy': newCsp},
      );
    };
  });

  for (final mw in config.middleware) {
    pipeline = pipeline.addMiddleware(mw);
  }

  Handler createHandler() {
    final router = createSparkRouter();

    router.mount(
      '/',
      createStaticHandler(staticPath, config: config!.staticConfig),
    );

    if (config!.notFoundHandler != null) {
      router.all('/<path|.*>', config!.notFoundHandler!);
    }

    return router.call;
  }

  Handler finalHandler;
  bool isDebug = false;
  assert(() {
    isDebug = true;
    return true;
  }());

  if (isDebug) {
    finalHandler = pipeline.addHandler((req) => createHandler()(req));
  } else {
    finalHandler = pipeline.addHandler(createHandler());
  }

  if (config.redirectToHttps && config.securityContext != null) {
    await shelf_io.serve(
      Pipeline()
          .addMiddleware((handler) {
            return (request) async {
              if (request.requestedUri.scheme == 'http') {
                return Response.movedPermanently(
                  request.requestedUri.replace(scheme: 'https').toString(),
                );
              }
              return handler(request);
            };
          })
          .addHandler((request) => Response.notFound('Not found')),
      config.host,
      80,
      shared:
          config.shared || (config.isolates != null && config.isolates! > 1),
    );
  }

  return shelf_io.serve(
    finalHandler,
    config.host,
    config.port,
    securityContext: config.securityContext,
    shared: config.shared || (config.isolates != null && config.isolates! > 1),
  );
}
