import 'dart:async';

import 'package:build/build.dart';
import 'package:glob/glob.dart';

/// Aggregating builder that collects all page route info
/// and generates the router configuration.
///
/// This builder:
/// 1. Finds all generated .spark.g.part files
/// 2. Parses route information from them
/// 3. Generates createSparkRouter() and createSparkServer() functions
class RouterBuilder implements Builder {
  @override
  Map<String, List<String>> get buildExtensions => {
    r'$lib$': ['spark_router.g.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Find all generated .spark.g.part files
    final sparkFiles = Glob('lib/**/*.spark.g.part');
    final routes = <_RouteInfo>[];
    final imports = <String>{};

    await for (final file in buildStep.findAssets(sparkFiles)) {
      log.info('RouterBuilder found part: ${file.path}');
      final content = await buildStep.readAsString(file);

      // Parse route info from the generated content
      final routeMatches = RegExp(
        r"const _\$(\w+)Route = \(([\s\S]*?)\);",
      ).allMatches(content);

      for (final match in routeMatches) {
        final className = match.group(1)!;
        final routeBody = match.group(2)!;

        final path = _extractValue(routeBody, 'path');
        final methods = _extractList(routeBody, 'methods');
        final pathParams = _extractList(routeBody, 'pathParams');

        // Extract the handler function
        final handlerMatch = RegExp(
          'Future<Response> _\\\$handle$className\\([\\s\\S]*?\\) async \\{[\\s\\S]*?\\n\\}',
        ).firstMatch(content);

        final handlerCode = handlerMatch?.group(0);

        if (path != null && handlerCode != null) {
          routes.add(
            _RouteInfo(
              className: className,
              path: path,
              methods: methods,
              pathParams: pathParams,
              handlerCode: handlerCode,
            ),
          );
        }
      }
      // Add import for the source file
      final sourcePath = file.path.replaceAll('.spark.g.part', '.dart');
      imports.add(sourcePath);
    }

    if (routes.isEmpty) {
      // No pages found, generate empty router
      await _writeEmptyRouter(buildStep);
      return;
    }

    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by spark_generator');
    buffer.writeln('// ignore_for_file: type=lint');
    buffer.writeln();

    // Imports
    buffer.writeln();
    buffer.writeln("import 'dart:convert';");
    buffer.writeln("import 'dart:io';");
    buffer.writeln("import 'dart:isolate';");
    buffer.writeln();
    buffer.writeln("import 'package:shelf/shelf.dart';");
    buffer.writeln("import 'package:shelf/shelf_io.dart' as shelf_io;");
    buffer.writeln("import 'package:shelf_router/shelf_router.dart';");
    buffer.writeln("import 'package:spark_framework/server.dart';");
    buffer.writeln();

    // Import source files that contain the page classes
    for (final import in imports) {
      final importPath = import.replaceFirst('lib/', '');
      buffer.writeln(
        "import 'package:${buildStep.inputId.package}/$importPath';",
      );
    }
    buffer.writeln();

    // Generate helper functions
    _writeHelperFunctions(buffer);

    // Generate handlers
    for (final route in routes) {
      buffer.writeln(route.handlerCode);
      buffer.writeln();
    }

    // Generate createSparkRouter
    buffer.writeln('/// Creates a router with all registered Spark pages.');
    buffer.writeln('///');
    buffer.writeln('/// This router contains handlers for:');
    for (final route in routes) {
      buffer.writeln('/// - `${route.path}` -> ${route.className}');
    }
    buffer.writeln('Router createSparkRouter() {');
    buffer.writeln('  final router = Router();');
    buffer.writeln();

    // Register each route
    for (final route in routes) {
      for (final method in route.methods) {
        final methodLower = method.toLowerCase();
        if (route.pathParams.isEmpty) {
          buffer.writeln(
            "  router.$methodLower('${route.path}', _\$handle${route.className});",
          );
        } else {
          buffer.writeln(
            "  router.$methodLower('${route.path}', (Request request, ${route.pathParams.map((p) => 'String $p').join(', ')}) =>",
          );
          buffer.writeln(
            '      _\$handle${route.className}(request, ${route.pathParams.join(', ')}));',
          );
        }
      }
    }
    buffer.writeln();
    buffer.writeln('  return router;');
    buffer.writeln('}');
    buffer.writeln();

    // Generate SparkServerConfig
    _writeServerConfig(buffer);

    // Generate createSparkServer
    _writeCreateSparkServer(buffer);

    // Write output
    final outputId = AssetId(
      buildStep.inputId.package,
      'lib/spark_router.g.dart',
    );
    await buildStep.writeAsString(outputId, buffer.toString());
  }

  Future<void> _writeEmptyRouter(BuildStep buildStep) async {
    final buffer = StringBuffer();

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by spark_generator');
    buffer.writeln('// ignore_for_file: type=lint');
    buffer.writeln();
    buffer.writeln('// No @Page annotations found in this package.');
    buffer.writeln(
      '// Add @Page annotations to classes that extend SparkPage.',
    );
    buffer.writeln();
    buffer.writeln("import 'dart:io';");
    buffer.writeln("import 'dart:isolate';");
    buffer.writeln();
    buffer.writeln("import 'package:shelf/shelf.dart';");
    buffer.writeln("import 'package:shelf/shelf_io.dart' as shelf_io;");
    buffer.writeln("import 'package:shelf_router/shelf_router.dart';");
    buffer.writeln("import 'package:spark/server.dart';");
    buffer.writeln();

    _writeHelperFunctions(buffer);

    buffer.writeln('/// Creates an empty router (no pages registered).');
    buffer.writeln('Router createSparkRouter() {');
    buffer.writeln('  return Router();');
    buffer.writeln('}');
    buffer.writeln();

    _writeServerConfig(buffer);
    _writeCreateSparkServer(buffer);

    final outputId = AssetId(
      buildStep.inputId.package,
      'lib/spark_router.g.dart',
    );
    await buildStep.writeAsString(outputId, buffer.toString());
  }

  void _writeHelperFunctions(StringBuffer buffer) {
    buffer.writeln('// Helper functions for page rendering');
    buffer.writeln();
    buffer.writeln('Response _\$renderPageResponse<T>(');
    buffer.writeln('  SparkPage<T> page,');
    buffer.writeln('  T data,');
    buffer.writeln('  PageRequest request,');
    buffer.writeln('  int statusCode,');
    buffer.writeln('  Map<String, String> headers,');
    buffer.writeln('  String? scriptName,');
    buffer.writeln(') {');
    buffer.writeln('  final content = page.render(data, request).toString();');
    buffer.writeln();
    buffer.writeln('  final title = page.title(data, request);');
    buffer.writeln();
    buffer.writeln('  final html = renderPage(');
    buffer.writeln('    title: title,');
    buffer.writeln('    content: content,');
    buffer.writeln('    scriptName: scriptName,');
    buffer.writeln('    stylesheets: page.stylesheets,');
    buffer.writeln('    additionalScripts: page.additionalScripts,');
    buffer.writeln('    inlineStyles: page.inlineStyles,');
    buffer.writeln('    headContent: page.headContent,');
    buffer.writeln('    lang: page.lang,');
    buffer.writeln('  );');
    buffer.writeln();
    buffer.writeln('  return Response(');
    buffer.writeln('    statusCode,');
    buffer.writeln('    body: html,');
    buffer.writeln('    headers: {');
    buffer.writeln("      'content-type': 'text/html; charset=utf-8',");
    buffer.writeln('      ...headers,');
    buffer.writeln('    },');
    buffer.writeln('  );');
    buffer.writeln('}');
    buffer.writeln();
    buffer.writeln(
      'Response _\$renderErrorResponse(String message, int statusCode) {',
    );
    buffer.writeln('  final html = renderPage(');
    buffer.writeln("    title: 'Error \$statusCode',");
    buffer.writeln("    content: '''");
    buffer.writeln('      <main style="text-align: center; padding: 40px;">');
    buffer.writeln('        <h1>Error \$statusCode</h1>');
    buffer.writeln('        <p>\$message</p>');
    buffer.writeln('      </main>');
    buffer.writeln("    ''',");
    buffer.writeln('  );');
    buffer.writeln();
    buffer.writeln('  return Response(');
    buffer.writeln('    statusCode,');
    buffer.writeln('    body: html,');
    buffer.writeln(
      "    headers: {'content-type': 'text/html; charset=utf-8'},",
    );
    buffer.writeln('  );');
    buffer.writeln('}');
    buffer.writeln();
  }

  void _writeServerConfig(StringBuffer buffer) {
    buffer.writeln('/// Configuration for the Spark server.');
    buffer.writeln('class SparkServerConfig {');
    buffer.writeln('  /// The host to bind to. Defaults to `localhost`.');
    buffer.writeln('  /// Can be a [String] or [InternetAddress].');
    buffer.writeln('  final Object host;');
    buffer.writeln();
    buffer.writeln('  /// The port to listen on. Defaults to `8080`.');
    buffer.writeln('  final int port;');
    buffer.writeln();
    buffer.writeln('  /// Middleware to apply to all requests.');
    buffer.writeln('  final List<Middleware> middleware;');
    buffer.writeln();
    buffer.writeln('  /// Configuration for static file serving.');
    buffer.writeln('  final StaticHandlerConfig? staticConfig;');
    buffer.writeln();
    buffer.writeln('  /// Handler for 404 errors.');
    buffer.writeln('  final Handler? notFoundHandler;');
    buffer.writeln();
    buffer.writeln('  /// Security context for HTTPS.');
    buffer.writeln('  final SecurityContext? securityContext;');
    buffer.writeln();
    buffer.writeln('  /// Whether to share the server socket.');
    buffer.writeln('  final bool shared;');
    buffer.writeln();
    buffer.writeln('  /// Whether to redirect HTTP to HTTPS.');
    buffer.writeln('  final bool redirectToHttps;');
    buffer.writeln();
    buffer.writeln('  /// Number of isolates (threads) to spawn.');
    buffer.writeln('  final int? isolates;');
    buffer.writeln();
    buffer.writeln('  /// Creates a server configuration.');
    buffer.writeln('  const SparkServerConfig({');
    buffer.writeln("    this.host = 'localhost',");
    buffer.writeln('    this.port = 8080,');
    buffer.writeln('    this.middleware = const [],');
    buffer.writeln('    this.staticConfig,');
    buffer.writeln('    this.notFoundHandler,');
    buffer.writeln('    this.securityContext,');
    buffer.writeln('    this.shared = false,');
    buffer.writeln('    this.redirectToHttps = false,');
    buffer.writeln('    this.isolates,');
    buffer.writeln('  });');
    buffer.writeln('}');
    buffer.writeln();
  }

  void _writeCreateSparkServer(StringBuffer buffer) {
    buffer.writeln(
      '/// Creates and starts a Spark server with all registered pages.',
    );
    buffer.writeln('///');
    buffer.writeln('/// ## Usage');
    buffer.writeln('///');
    buffer.writeln('/// ```dart');
    buffer.writeln('/// void main() async {');
    buffer.writeln(
      '///   final server = await createSparkServer(SparkServerConfig(',
    );
    buffer.writeln('///     port: 8080,');
    buffer.writeln('///     middleware: [logRequests()],');
    buffer.writeln('///   ));');
    buffer.writeln(
      "///   print('Server running at http://\${server.address.host}:\${server.port}');",
    );
    buffer.writeln('/// }');
    buffer.writeln('/// ```');
    buffer.writeln(
      'Future<HttpServer> createSparkServer([SparkServerConfig? config]) async {',
    );
    buffer.writeln('  config ??= const SparkServerConfig();');
    buffer.writeln();
    buffer.writeln('  // Auto-detect static path based on runtime environment');
    buffer.writeln(
      "  final isDevMode = Platform.environment.containsKey('SPARK_DEV_RELOAD_PORT');",
    );
    buffer.writeln("  final staticPath = isDevMode ? 'build/web' : 'web';");
    buffer.writeln();
    buffer.writeln('  // Automatic threading');
    buffer.writeln('  if (config.isolates != null && config.isolates! > 1) {');
    buffer.writeln(
      "    if (Platform.environment['SPARK_WORKER_ID'] == null) {",
    );
    buffer.writeln(
      "      print('[Master] Spawning \${config.isolates! - 1} workers...');",
    );
    buffer.writeln('      // Allow the master to also serve');
    buffer.writeln('      for (var i = 1; i < config.isolates!; i++) {');
    buffer.writeln('        Isolate.spawnUri(');
    buffer.writeln('          Platform.script,');
    buffer.writeln('          [],');
    buffer.writeln('          null,');
    buffer.writeln('          packageConfig: await Isolate.packageConfig,');
    buffer.writeln(
      "          environment: {'SPARK_WORKER_ID': '\$i', ...Platform.environment},",
    );
    buffer.writeln('        );');
    buffer.writeln('      }');
    buffer.writeln('    } else {');
    buffer.writeln(
      "      print('[Worker] Started worker \${Platform.environment['SPARK_WORKER_ID']}');",
    );
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();
    buffer.writeln('  var pipeline = const Pipeline();');
    buffer.writeln('  ');
    buffer.writeln('  // Add global error handler');
    buffer.writeln('  pipeline = pipeline.addMiddleware((innerHandler) {');
    buffer.writeln('    return (request) async {');
    buffer.writeln('      try {');
    buffer.writeln('        return await innerHandler(request);');
    buffer.writeln('      } on ApiError catch (e) {');
    buffer.writeln('         return e.toResponse();');
    buffer.writeln('      } catch (e, s) {');
    buffer.writeln('        print(e);');
    buffer.writeln('        print(s);');
    buffer.writeln('        return Response.internalServerError();');
    buffer.writeln('      }');
    buffer.writeln('    };');
    buffer.writeln('  });');
    buffer.writeln('');
    buffer.writeln('  for (final mw in config.middleware) {');
    buffer.writeln('    pipeline = pipeline.addMiddleware(mw);');
    buffer.writeln('  }');
    buffer.writeln();
    buffer.writeln('  Handler createHandler() {');
    buffer.writeln('    final router = createSparkRouter();');
    buffer.writeln();
    buffer.writeln("    router.mount('/', createStaticHandler(");
    buffer.writeln('      staticPath,');
    buffer.writeln('      config: config!.staticConfig,');
    buffer.writeln('    ));');
    buffer.writeln();
    buffer.writeln('    if (config!.notFoundHandler != null) {');
    buffer.writeln("      router.all('/<path|.*>', config!.notFoundHandler!);");
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    return router.call;');
    buffer.writeln('  }');
    buffer.writeln();
    buffer.writeln('  Handler finalHandler;');
    buffer.writeln('  bool isDebug = false;');
    buffer.writeln('  assert(() { isDebug = true; return true; }());');
    buffer.writeln();
    buffer.writeln('  if (isDebug) {');
    buffer.writeln(
      '    finalHandler = pipeline.addHandler((req) => createHandler()(req));',
    );
    buffer.writeln('  } else {');
    buffer.writeln('    finalHandler = pipeline.addHandler(createHandler());');
    buffer.writeln('  }');
    buffer.writeln();
    buffer.writeln(
      '  if (config.redirectToHttps && config.securityContext != null) {',
    );
    buffer.writeln('     await shelf_io.serve(');
    buffer.writeln('        Pipeline()');
    buffer.writeln('          .addMiddleware((handler) {');
    buffer.writeln('            return (request) async {');
    buffer.writeln(
      "              if (request.requestedUri.scheme == 'http') {",
    );
    buffer.writeln('                return Response.movedPermanently(');
    buffer.writeln(
      '                  request.requestedUri.replace(scheme: \'https\').toString(),',
    );
    buffer.writeln('                );');
    buffer.writeln('              }');
    buffer.writeln('              return handler(request);');
    buffer.writeln('            };');
    buffer.writeln('          })');
    buffer.writeln(
      '          .addHandler((request) => Response.notFound(\'Not found\')),',
    );
    buffer.writeln('        config.host,');
    buffer.writeln('        80,');
    buffer.writeln(
      '        shared: config.shared || (config.isolates != null && config.isolates! > 1),',
    );
    buffer.writeln('      );');
    buffer.writeln('  }');
    buffer.writeln();
    buffer.writeln('  return shelf_io.serve(');
    buffer.writeln('    finalHandler,');
    buffer.writeln('    config.host,');
    buffer.writeln('    config.port,');
    buffer.writeln('    securityContext: config.securityContext,');
    buffer.writeln(
      '    shared: config.shared || (config.isolates != null && config.isolates! > 1),',
    );
    buffer.writeln('  );');
    buffer.writeln('}');
  }

  String? _extractValue(String body, String key) {
    final match = RegExp("$key: '([^']*)'").firstMatch(body);
    return match?.group(1);
  }

  List<String> _extractList(String body, String key) {
    final match = RegExp('$key: <String>\\[([^\\]]*)\\]').firstMatch(body);
    if (match == null) return [];
    final content = match.group(1)!;
    if (content.trim().isEmpty) return [];
    return content.split(',').map((s) {
      final trimmed = s.trim();
      // Remove quotes
      if (trimmed.startsWith("'") && trimmed.endsWith("'")) {
        return trimmed.substring(1, trimmed.length - 1);
      }
      return trimmed;
    }).toList();
  }
}

class _RouteInfo {
  final String className;
  final String path;
  final List<String> methods;
  final List<String> pathParams;
  final String handlerCode;

  _RouteInfo({
    required this.className,
    required this.path,
    required this.methods,
    required this.pathParams,
    required this.handlerCode,
  });
}
